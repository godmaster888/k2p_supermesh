"use strict";!function(){angular.module("app").controllerProvider.register("VserversRuleCtrl",["$scope","$rootScope","$state","translate","history","funcs","vserversUtil","vserversTemplate",function($scope,$rootScope,$state,translate,history,funcs,util,template){function getProtocolList(){if(!vservers.config)return[];var posProtocols=function(){var type=vservers.rule.Type||"custom",templ=_.find(template,function(e){return e.Type==type});return templ&&templ.ProtocolList?templ.ProtocolList:["TCP","UDP","TCP/UDP"]}();return helper.getProtocolList(["TCP","UDP","TCP/UDP"],posProtocols)}function validation(newValue,param){var ipValidation,rule=vservers.rule;if(!rule)return null;var errors=helper.validation(rule,__index,vservers.config)[param];return"public"==param&&(ipValidation=vservers.ipValidation(newValue,"private"),ipValidation&&errors.push(ipValidation)),errors.length?errors[0]:null}function wasModified(){return!_.isEqual(vservers.rule,__backupRule)}function filterPrivateList(elem){return elem?helper.isPrivateIP(vservers.config.LAN,elem.ip):!1}function __updateUseSourcePorts(){var rule=vservers.rule;if(rule){var curIndex=_.isUndefined(__index)?void 0:__index.toString();vservers.useSourcePorts=helper.getUseSourcePorts(vservers.config.UsedSourcePorts,rule,curIndex)}}function ipValidation(addr,type,inx){return helper.ipValidation(addr,type,vservers.rule,inx)}$scope.vservers={isActivate:!1,action:null,rule:null,useSourcePorts:null,apply:function(){function success(){$state.go(currentState+".info")}if($scope.form.$valid){var overlayId=overlay.start();vservers.rule.Source.IP.length>1&&(vservers.rule.Source.IP=_.compact(vservers.rule.Source.IP)),util.applyRule(vservers.rule,__index).then(success)["catch"](function(){$state.go("error",{code:"msg_push_error",message:"msg_error_desc"})})["finally"](function(){overlayId&&overlay.stop(overlayId)})}},remove:function(){function success(){history.setCleanLastHistory(!0),$state.go(currentState+".info")}if(confirm(translate("vservers_rule_remove_warning"))){var overlayId=overlay.start();$rootScope.$emit("unsavedStop",!0),util.removeRules([vservers.rule]).then(success)["catch"](function(){$state.go("error",{code:"msg_push_error",message:"msg_error_desc"})})["finally"](function(){overlayId&&overlay.stop(overlayId)})}},addSourceIp:function(){vservers.rule.Source.IP.push(""),vservers.sourceIpfocus=!0},removeSourceIp:function(ip,inx){vservers.rule.Source.IP.splice(inx,1)},validation:validation,isDisabled:function(param){var type,rule=vservers.rule;if(!rule)return!1;switch(param){case"Source.Iface":return rule.SNAT;case"Source.Ports":case"Dest.Ports":if(type=rule.Type,"sftp"==type||"pcanywhere"==type||"wakeonlan"==type)return!0;break;case"Dest.IP":return"wakeonlan"==rule.Type}return!1},changeType:function(type){var input=_.find(template,function(e){return e.Type==type});input&&(_.has(vservers.rule.Source.Ports[1],"PortType")&&(input.Source.Ports[1].PortType=funcs.deepClone(vservers.rule.Source.Ports[1].PortType)),_.extend(vservers.rule.Source.Ports,input.Source.Ports),_.has(vservers.rule.Dest.Ports[1],"PortType")&&(input.Dest.Ports[1].PortType=funcs.deepClone(vservers.rule.Dest.Ports[1].PortType)),_.extend(vservers.rule.Dest.Ports,input.Dest.Ports),input.Dest.IP&&_.extend(vservers.rule.Dest.IP,input.Dest.IP),"255.255.255.255"==vservers.rule.Dest.IP[0]&&"wakeonlan"!=type&&(vservers.rule.Dest.IP[0]=""),vservers.rule.Proto=input.ProtocolList[0])},changeParam:function(param,value){if(!vservers.rule)return null;switch(param){case"SNAT":value&&(vservers.rule.Source.Iface="all")}},getTypesList:function(){var types=_.map(template,function(elem){return{name:elem.Name,value:elem.Type}}),hasWakeOnLANRule=_.findWhere(vservers.config.Rules,{Type:"wakeonlan"});return hasWakeOnLANRule?__index&&hasWakeOnLANRule.__id==__index?types:_.filter(types,function(e){return"wakeonlan"!=e.value}):types},getInterfaceList:function(){var output=[];return vservers.config?(output.push({Name:"all",Value:"all"}),output=output.concat(vservers.config.Ifaces)):output},getProtocolList:getProtocolList,filterPrivateList:filterPrivateList,wasModified:wasModified,showUseSourcePorts:function(){return _.chain(vservers.useSourcePorts).sortBy(function(elem){return parseInt(elem.startPort)}).map(function(elem){return elem.startPort&&elem.endPort?elem.startPort+" - "+elem.endPort:elem.startPort?elem.startPort:elem.endPort?elem.endPort:void 0}).uniq().compact().join(", ")},getDescSourceBusyPorts:function(){return"vservers_source_busy_ports"},portsTypeValidation:function(){return vservers.rule.Dest.Ports[1].PortType!=vservers.rule.Source.Ports[1].PortType?"vservers_port_wrong_type":null},ipValidation:ipValidation};var helper,vservers=$scope.vservers,overlay=$scope.overlay.circular,__index=_.isUndefined($state.params.inx)?void 0:parseInt($state.params.inx),__backupRule=null,currentState=$state.current.name.split(".");currentState.pop(),currentState=currentState.join("."),function(overlayId){util.pull().then(function(){helper=util.makeHelper(),vservers.config=util.getConfig(),_.isUndefined(__index)?(vservers.rule=util.getDefaultRule(),vservers.action="add"):(vservers.rule=_.find(vservers.config.Rules,function(r){return r.__id==__index}),vservers.action="edit"),__backupRule=angular.copy(vservers.rule)})["catch"](function(){$state.go("error",{code:"msg_pull_error",message:"msg_error_desc"})})["finally"](function(){overlayId&&overlay.stop(overlayId),$scope.$emit("pageload"),vservers.isActivate=!0})}(),$scope.$watch("vservers.rule.Source.Iface",__updateUseSourcePorts),$scope.$watch("vservers.rule.Proto",__updateUseSourcePorts)}])}();